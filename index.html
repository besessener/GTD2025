<!doctype html>
<html lang="en">

<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

	<title>GTD2025</title>

	<link rel="stylesheet" href="dist/reset.css">
	<link rel="stylesheet" href="dist/reveal.css">
	<link rel="stylesheet" href="dist/theme/black.css">
	<link rel="stylesheet" href="plugin/pointer/pointer.css" />

	<!-- Theme used for syntax highlighted code -->
	<link rel="stylesheet" href="plugin/highlight/monokai.css">
</head>

<body>
	<div class="reveal">
		<div class="slides">
			<section>
				<h2>Wenn Performancetest-Tools unter ihrer eigenen Last zusammenbrechen</h2>
				<p><img src="images/cover.png" style="width:40%"></p>
			</section>
			<section>
				<h2>Agenda 📋</h2>
				<ul>
					<li>kurze Vorstellung</li>
					<li>Testobjekt</li>
					<li>Performance-Testing</li>
					<li>Apache JMeter</li>
					<li>Test Setup & Durchführung</li>
					<li>Ergebnisse</li>
					<li>Fazit</li>
				</ul>
			</section>
			<section>
				<h2>Der Sprecher 🙊</h2><img src="images/matthias.png" class="r-stretch">
				<p>Matthias Eggert</p>
			</section>
			<section>
				<section>
					<h2>Testobjekt 🧫</h2>
				</section>
				<section>
					<h2>Demokratischer Prozess 🗽</h2>
					<ul>
						<li>Viele Millionen Menschen, Dienste und Crawler</li>
						<li>7-stellige Zahl von Requests pro Minute</li>
						<li>Und zwar in der Regel genau an einem Tag</li>
						<li>Auf unterschiedliche Endpunkte</li>
					</ul>
				</section>
				<section data-background-color="white"><img src="images/halber-donut.png" class="r-stretch"></section>
				<section data-background-color="white"><img src="images/donuts.png" class="r-stretch"></section>
				<section>
					<h2>Zurück zum Testobjekt 🗽</h2>
					<ul>
						<li>Viele Millionen Menschen, Dienste und Crawler</li>
						<li>7-stellige Zahl von Requests pro Minute</li>
						<li>Und zwar in der Regel genau an einem Tag</li>
						<li>Auf unterschiedliche Endpunkte</li>
						<li>Große Responses</li>
						<li>DDoS</li>
					</ul>
				</section>
			</section>
			<section>
				<section>
					<h2>Performance-Testing ⏱️</h2>
				</section>
				<section>
					<img src="images/chuck.png" alt="Chuck Norris" class="r-stretch">
					<h1 class="fragment">💩</h1>
				</section>
				<section>
					<h2>Performance-Testing Arten 🏋️🧘🚣🏃</h2>
					<img src="images/performance-tests-types.png" alt="Performance-Testing Arten" class="r-stretch">
					<aside class="notes">
						Performance-Tests umfassen verschiedene Testarten, darunter Lasttests, Stress-Tests und
						Ausdauer- oder Dauertests. Jede dieser Testarten zielt darauf ab, unterschiedliche
						Leistungsaspekte einer Anwendung zu bewerten. Zum Beispiel:

						- Lasttests simulieren eine typische Nutzerbelastung, um zu sehen, wie die Anwendung unter
						normalen Bedingungen funktioniert.
						- Stress-Tests erhöhen die Belastung schrittweise über das normale Niveau hinaus, um die Grenzen
						der Anwendung zu finden.
						- Kapazitäts-Tests gehen mit Absicht über die Grenzen der Anwendung hinaus, um zu sehen, wie sie
						scheitert.
						- Ausdauer-Tests prüfen die Anwendung auf ihre Fähigkeit, über einen langen Zeitraum unter
						erwarteter Belastung zuverlässig zu funktionieren.

						Durch Performance-Tests können wir Engpässe identifizieren, die Leistung optimieren und
						sicherstellen, dass unsere Anwendung auch unter Spitzenlast oder bei steigender Nutzerzahl
						zuverlässig funktioniert. Mit diesem grundlegenden Verständnis von Performance-Tests können wir
						nun einen spezifischeren Blick auf Apache JMeter werfen und verstehen, wie es uns unterstützt,
						unsere Anwendungen zu testen.
					</aside>
				</section>
				<section>
					<h2>Auto-Scaling What 🚗🤔❓</h2>
					<img src="images/cloud.webp" class="r-stretch">
					<aside class="notes">
						Open source apache foundation
						Verhältnismäßg resourcenhungrig
						Aber zuverlässig
				</section>
				<section>
					<h2>Konstante Hochlast ↗️</h2>
					<img src="images/hochlast.png" alt="Performance-Testing Arten" class="r-stretch">
				</section>
			</section>
			<section>
				<section>
					<section>
						<h2>Apache JMeter 🪶</h2>
						<ul>
							<li>Open Source</li>
							<li>Java basiert</li>
							<li>GUI und CLI</li>
							<li>Skalierbar</li>
							<li>Plugins</li>
						</ul>
						<aside class="notes">
							Apache JMeter ist ein mächtiges Open-Source-Tool, das vorwiegend für Performance-Tests und
							Lasttests von Anwendungen eingesetzt wird. Entwickelt in Java, bietet JMeter eine flexible
							Plattform für die Bewertung der Leistung von Webanwendungen.

							JMeter kann sowohl über eine grafische Benutzeroberfläche (GUI) als auch über die
							Kommandozeilenschnittstelle (CLI) bedient zu werden. Während die GUI insbesondere während
							der
							Testentwicklungsphase für ihre Benutzerfreundlichkeit und visuelle Rückmeldung geschätzt
							wird,
							ermöglicht die CLI einen effizienteren Betrieb in Testumgebungen, was besonders bei der
							Integration in CI/CD-Pipelines nützlich ist. Oder eben auch für eine Integration in
							Cloud-Lösungen wie Azure Load Testing. Wir haben es auch in einer eigenen cloud-basierten
							Lasttestlösung im Einsatz, QLoad.

							JMeter zeichnet sich durch seine Skalierbarkeit aus. Es kann auf einzelnen Workstations für
							einfache Testaufgaben eingesetzt werden, lässt sich aber auch in großem Umfang für komplexe
							Lasttests verwenden, die mehrere Server umfassen können. Diese Skalierbarkeit macht es zu
							einem
							idealen Werkzeug für Unternehmen jeder Größe, um die Leistung ihrer Anwendungen unter
							verschiedenen Lastbedingungen zu bewerten.

							Ein weiteres wichtiges Merkmal von JMeter sind die zahlreichen verfügbaren Plugins, die
							seine
							Funktionalität erweitern. Diese Plugins ermöglichen es den Benutzern, neue Testfähigkeiten
							hinzuzufügen, die Anpassung von Berichten zu verbessern und die Integration mit anderen
							Tools
							und Plattformen zu vereinfachen. Obwohl JMeter bereits eine umfassende Palette an
							Testmöglichkeiten bietet, erlauben es diese Plugins, das Tool noch weiter an spezifische
							Bedürfnisse anzupassen. Die Entwicklung eigener Plugins ist ebenfalls möglich, was die
							Flexibilität von JMeter zusätzlich erhöht.

							Insgesamt bietet Apache JMeter als ein vielseitiges, leistungsstarkes Tool für
							Performance-Testing und Lasttest eine robuste Lösung für Entwickler und
							Qualitätssicherungs-Teams. Seine Open-Source-Natur, gepaart mit umfangreicher Dokumentation
							und
							einer aktiven Community, macht es zu einer zugänglichen und wertvollen Ressource für die
							Optimierung der Leistung von Webanwendungen und anderen Diensten.
						</aside>
					</section>
				</section>
				<section>
					<h2>JMeter Skalieren ⚖️</h2>
					<img src="images/jmeter-controller-worker.png" class="r-stretch">
					<aside class="notes">
						(K6 angeblich 5 mio pro Minute von einer Maschine)
					</aside>
				</section>
				<section>
					<h2>⛅ = 😇</h2>
					<aside class="notes">
						Ich sehe alles in grafana live, ich kann mir den report anschauen. also bestimmt. super viel
						last erzeugen dank der cloud. Funktioniert auch echt super. oder nicht?
					</aside>
				</section>
				<section>
					<h2>⛈️ = 😈</h2>
				</section>
			</section>
			<section>
				<section>
					<h2>Testarchitektur I 🏗️</h2>
				</section>
				<section data-background-color="white">
					<img src="images/arch1.png" class="r-stretch">
				</section>
			</section>
			<section>
				<section>
					<h2>Fehlschlag 🪠</h2>
					<ul class="fragment">
						<li>RAM, CPU, Netzwerk</li>
						<li>RAM stieg noch weiter an, wenn man zu wenig Netzwerk hatte</li>
						<li>Reporterstellung (mindestens x5)</li>
						<ul>
							<li>Nicht denken, dass es kaputt ist, es dauert nur ewig</li>
						</ul>
						<li>Grafana konnte nur noch 30 Sekunden Fenster laden</li>
						<li>Aber Zeitdruck</li>
					</ul>
					<aside class="notes">
						http://localhost:3000/d/PyR6xlG7z/system-monitoring-with-influxdb-cloud-and-telegraf?orgId=1&from=2024-04-16T14:27:42.853Z&to=2024-04-16T18:25:47.945Z&var-bucket=3-2-KommONE&var-hosts=$__all
						http://localhost:3000/d/PyR6xlG7z/system-monitoring-with-influxdb-cloud-and-telegraf?orgId=1&from=2024-04-21T22:00:00.000Z&to=2024-04-24T21:59:59.000Z&var-bucket=3-2-xl&var-hosts=$__all
						http://localhost:3000/d/PyR6xlG7z/system-monitoring-with-influxdb-cloud-and-telegraf?orgId=1&from=2024-04-23T07:25:44.162Z&to=2024-04-23T13:19:07.926Z&var-bucket=3-2-xxl&var-hosts=$__all
						http://localhost:3000/d/PyR6xlG7z/system-monitoring-with-influxdb-cloud-and-telegraf?orgId=1&from=2024-04-22T13:29:18.374Z&to=2024-04-22T14:16:11.560Z&var-bucket=3-2-xl&var-hosts=$__all

						------
						http://localhost:3000/d/PyR6xlG7z/system-monitoring-with-influxdb-cloud-and-telegraf?orgId=1&from=2024-12-02T15:33:17.987Z&to=2024-12-02T15:38:43.410Z&var-bucket=3-2-l&var-hosts=$__all&refresh=5s
						http://localhost:3000/d/PyR6xlG7z/system-monitoring-with-influxdb-cloud-and-telegraf?orgId=1&from=2024-12-02T15:48:08.702Z&to=2024-12-02T15:51:02.601Z&var-bucket=3-2-l&var-hosts=$__all&refresh=5s
						http://localhost:3000/d/PyR6xlG7z/system-monitoring-with-influxdb-cloud-and-telegraf?orgId=1&from=2024-12-02T16:25:22.202Z&to=2024-12-02T16:29:01.066Z&var-bucket=3-2-l&var-hosts=$__all&refresh=5s
						-----
						http://localhost:3000/d/PyR6xlG7z/system-monitoring-with-influxdb-cloud-and-telegraf?orgId=1&from=2024-12-03T12:22:50.417Z&to=2024-12-03T12:32:27.058Z&var-bucket=3-2-l&var-hosts=$__all&refresh=auto
						http://localhost:3000/d/PyR6xlG7z/system-monitoring-with-influxdb-cloud-and-telegraf?orgId=1&from=2024-12-03T12:34:19.307Z&to=2024-12-03T13:08:56.282Z&var-bucket=3-2-l&var-hosts=$__all&refresh=auto
					</aside>
				</section>
				<section><img src="images/run1.png" class="r-stretch"></section>
				<section>
					<h2>🪲🐞</h2>
					<blockquote class="r-stretch">However, remote mode does use more resources than running the same
						number of CLI mode tests independently. If many server instances are used, the client JMeter can
						become overloaded, as can the client network connection. This has been improved by switching to
						Stripped modes (see below) but you should always check that your client is not overloaded.
					</blockquote>
				</section>
				<section>
					<blockquote class="r-stretch">
						Note that while you can execute the JMeterEngine on your application server, you need to be
						mindful of the fact that this will be adding processing overhead on the application server and
						thus your testing results will be somewhat tainted. The recommended approach is to have one or
						more machines on the same Ethernet segment as your application server that you configure to run
						the JMeter Engine. This will minimize the impact of the network on the test results without
						impacting the performance of the application server itself.</blockquote>
				</section>
				<section>
					<h2>JMeter Master Config ⚙️</h2><img src="images/jmeter-master-config.png" class="r-stretch">
				</section>
			</section>
			<section>
				<section>
					<h2>Testarchitektur II 🏛️🛕</h2>
				</section>
				<section>
					<h2>First things first</h2>
					<code>mehr RAM, mehr Netzwerkbandbreite</code>
				</section>
				<section><img src="images/run2.png"></section>
				<section><img src="images/run3.png"></section>
				<section><img src="images/run-up-and-down.png" class="r-stretch"></section>
				<section data-background-color="white">
					<h2>🆕🆕🆕</h2>
					<img src="images/arch2.png" class="r-stretch">
					<aside class="notes">
						QLoad + Jenkins
						Kann jeder, auch ohne cloud Kenntnisse
						Einfach agents starten und tests unabhängig laufen lassen
						Am ende reports einsammeln und gesamtreport erstellen


						Wir konnten mehr, aber es wurde immer langsamer
						Keine Fehler
						Schwierigkeit die richtige balance aus agents und cpu last zu finden
						Und wir waren nur statisch unterwegs
						Fargate könnte man hier schon vergessen, interne netzwerklast ist zu hoch

					</aside>
				</section>
				<section><img src="images/config-real.png"></section>
				<section><img src="images/run-real.png"></section>
				<section>
					<h2>StrippedBatch O.M.G. 😱</h2>
					<code>mode=StrippedBatch</code>
				</section>
				<section>
					<code>mode=StrippedBatch</code>
					<img src="images/run-stripped.png" class="r-stretch">
				</section>
			</section>
			<section>
				<section>
					<h2>Ergebnisse 📉</h2>
				</section>
				<section>
					<h2>Grafana 📈</h2>
					<img src="images/ergebnisse-grafana.png" class="r-stretch">
				</section>
				<section>
					<h2>Python 🐍</h2>
					<img src="images/ergebnis.png" class="r-stretch">
					<aside class="notes">
						Nicht vorenthalten
						Ein Traum für jeden Performancetester…zumindest fast:
					</aside>
				</section>
				<section>
					<img src="images/ergebnis2.png" class="r-stretch">
					<aside class="notes">
						am Ende hat mit Skalierung geklappt, und wir waren froh es ausprobiert zu haben. Aber es lief
						von Anfang an stabil, es gab nie Fehler.
					</aside>
				</section>
			</section>
			<section>
				<h2>Lösungsansätze (mittel-/langfristig) ⭐</h2>
				<ul>
					<li>mehrere Systeme für Lastagenten</li>
					<li>Responses nicht im report speichern (StrippedBatch)</li>
					<li>Report asynchron laufen lassen</li>
					<li>Custom Listener der Responses nur im Fehlerfall speichert</li>
					<li>K6 statt JMeter (Kein Reporting, Kein Master-Slave; Aber ...)</li>
				</ul>
			</section>
			<section>
				<h2>Fazit 🩻</h2>
				<ul>
					<li>Performance-Tests sind essenziell für die Zuverlässigkeit von Anwendungen.</li>
					<li>Apache JMeter ist ein mächtiges Tool, aber nicht ohne Herausforderungen.</li>
					<li>Skalierung und Ressourcenmanagement sind kritische Faktoren.</li>
					<li>Cloud-basierte Lösungen bieten Potenzial, aber auch neue Probleme.</li>
					<li>Kontinuierliche Optimierung und Anpassung sind notwendig.</li>
				</ul>
			</section>
			<section>
				<h2>Vielen Dank! 🙏</h2>
			</section>
		</div>
	</div>

	<script src="dist/reveal.js"></script>
	<script src="plugin/notes/notes.js"></script>
	<script src="plugin/markdown/markdown.js"></script>
	<script src="plugin/highlight/highlight.js"></script>
	<script src="plugin/pointer/pointer.js"></script>
	<script src="plugin/zoom/zoom.js"></script>
	<script src="plugin/search/search.js"></script>
	<script>
		Reveal.initialize({
			pointer: {
				key: "q", // key to enable pointer, default "q", not case-sensitive
				color: "red", // color of a cursor, default "red" any valid CSS color
				opacity: 0.8, // opacity of cursor, default 0.8
				pointerSize: 30, // pointer size in px, default 12
				alwaysVisible: false, // should pointer mode be always visible? default "false"
				tailLength: 10, // NOT IMPLEMENTED YET!!! how long the "tail" should be? default 10
			},
			slideNumber: 'c/t',
			hash: true,
			plugins: [RevealMarkdown, RevealHighlight, RevealNotes, RevealPointer, RevealZoom, RevealSearch]
		});
	</script>
</body>

</html>